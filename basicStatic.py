#!/usr/bin/env python
#author: Frank Di Giglio

import argparse
import pefile
import os
import requests
import hashlib
import datetime
import json

parser = argparse.ArgumentParser(description="Run Basic Static Analysis on a specific executable.")
parser.add_argument("-f", "--file", type=str, help="Executable to run Basic Static Analysis")
parser.add_argument("-o", "--output", default="dataSample/", type=str, help="Output path of directory for collection of data, e.g data/")
parser.add_argument("-a", "--api", type=str, help="API Key the user acquires from VirusTotal")
parser.add_argument("-n", "--number", type=str, help="Minimum number of characters to filter out when using Strings")
args = parser.parse_args()
filename = args.file
out = args.output
apiKey = args.api
num = args.number
subsystem_dict = dict()
machine_dict = dict()
rsrc = dict()

try:
    if not os.path.exists(out):
        os.makedirs(out)
    else:
        pass
        #Path already exists
except FileNotFoundError:
    pass

# filename = input("Enter filename: ") #Uncomment for when not using argparse
pe = pefile.PE(filename)

def basicStrings(file):
    """
    Will run strings on the executable and then the user can input the min num of characters for an executable
    User specifies the name of the output file for strings
    """
    outputFile = "strings_data.txt"
    numOfCharactersToCheck = str(num)
    #Strings output is stored
    #Checks if user inputs a slash for the filepath
    if str(out).endswith("/") or len(str(out)) == 0:
        strings = str(os.system("strings64.exe -nobanner -n " + numOfCharactersToCheck + " " + str(filename) + " > " + out + outputFile))
    else:
        print("Invalid path, please rerun command")

# subsystem_value = ""
# machine_value = ""
def architecture(file):
    """
    Function that appends the architecture of the executable it is meant to run in to the report as well as the subsystem
    """
    global machine_value
    global subsystem_value
    dictionary = pe.dump_dict()

    #SEEMS TO OUTPUT A KEY VALUE PAIRING

    #DOSHEADER 
    dosheader = dictionary.get("DOS_HEADER")
    # print(dosheader)
    
    #SEEMS TO OUTPUT A KEY VALUE PAIRING
    ntheader = dictionary.get("NT_HEADERS")
        
    #SEEMS TO OUTPUT A KEY VALUE PAIRING
    fileheader = dictionary.get("FILE_HEADER")
    # print(fileheader)

    machine = fileheader.get("Machine")
    #Value needed to match
    machineValue = machine.get("Value")
    #Iterate through the machine types until the value matches the 1st index of the tuple
    for i in range(len(pefile.machine_types)):
        machType = pefile.machine_types[i]
        if machType[1] == machineValue:
            machVar = machType[0]
            machine_value = machVar

    #List
    flags = dictionary.get("Flags")
    # print(flags)

    #SEEMS TO OUTPUT A KEY VALUE PAIRING
    optionalheader = dictionary.get("OPTIONAL_HEADER")
    # print(optionalheader)
    system = optionalheader.get("Subsystem")

    #EXAMPLE:
    #TO GET THE DICTIONARY TYPES YOU NEED TO ACCESS FROM THE CLASS ITSELF 

    #This next line prints/stores the subsystem of the PE, index 0 represents the tuple the function returns to only specify the string
    subsystemVar = pefile.subsystem_types[system.get("Value")][0]
    subsystem_value = subsystemVar

    # print(dictionary.get("DllCharacteristics"))
    # print(dictionary.get("PE Sections"))
    # print(dictionary.get("Directories"))
    #RESOURCE HACKER SECTION                                TODO
    # print(dictionary.get("Resource directory"))
    rsrc = str(dictionary.get("Resource directory"))
    #Output None if there is no .rsrc section 
   



dependWalkerCMD = []
def dependencies(file):
    """
    Function to retrive DLL/Imports within a PE
    When written to a file, it will be formatted in a parent/child approach
    """

    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        entry_dict = {}
        entry_list = []
        for imp in entry.imports:
            value = '\t', imp.name
            try:
                entry_list.append(value[1].decode())
            except AttributeError:
                print("No DLLs...")
        entry_dict = {entry.dll.decode(): entry_list}
        dependWalkerCMD.append(entry_dict)
   
        

def getHash(filename):
    """
    Helper function to get the hash value of a file
    """
    h = hashlib.sha256()

    with open(filename, 'rb') as file:
        while True:
            # Reading is buffered, so we can read smaller chunks.
            chunk = file.read(h.block_size)
            if not chunk:
                break
            h.update(chunk)

    return h.hexdigest()


def packer(filename):
    pass


def virusTotal(filename):
    """
    Function to interact with VirusTotal API
    """
    hashFile = getHash(filename)
    # apiKey = input("Enter API Key for Virus Total: ")

    url = "https://www.virustotal.com/api/v3/files/" + str(hashFile)

    headers = {
        "accept": "application/json",
        "x-apikey": apiKey #Delete API key before pushing to github
    }

    response = requests.get(url, headers=headers)
    data = response.json() #returns a dictionary
    #API keys are held with a nested dictionary
    #Need to convert UTC integer into readable format
    try:
        creation_date = datetime.datetime.utcfromtimestamp(int(data.get("data").get("attributes").get("creation_date"))).strftime("%m/%d/%Y, %H:%M:%S") + " UTC"
        creation_date_dict = {"CREATION_DATE": creation_date}
        
        first_submission_date = datetime.datetime.utcfromtimestamp(int(data.get("data").get("attributes").get("first_submission_date"))).strftime("%m/%d/%Y, %H:%M:%S") + " UTC"
        first_submission_date_dict = {"FIRST_SUBMISSION_DATE": first_submission_date}
        
        names = data.get("data").get("attributes").get("names")
        names_dict = {"NAMES": names}

        total_votes = data.get("data").get("attributes").get("total_votes")
        total_votes_dict = {"TOTAL_VOTES":total_votes}

        type_description = data.get("data").get("attributes").get("type_description")
        type_description_dict = {"TYPE_DESCRIPTION": type_description}

        last_analysis_stats = data.get("data").get("attributes").get("last_analysis_stats")
        last_analysis_stats_dict = {"LAST_ANALYSIS_STATS": last_analysis_stats}

        sandbox_verdicts = data.get("data").get("attributes").get("sandbox_verdicts")
        sandbox_verdicts_dict = {"SANDBOX_VERDICTS": sandbox_verdicts}

        size = data.get("data").get("attributes").get("size")
        size_dict = {"SIZE": size}

        # print(dependWalkerCMD)
        dependWalkerCMD_dict = {"DLLs_and_Imports": dependWalkerCMD}
        # print(dependWalkerCMD_dict)

        subsystem_dict = {"Subsystem Type": subsystem_value}
        machine_dict = {"Machine Type": machine_value}
    

        #Need to replace the single quotes inside the dictionary with double quotes in order for json.loads to work
        try:
            creation_date = creation_date.replace("'", '"')
        except:
            pass

        try:
            first_submission_date = first_submission_date.replace("'", '"')
        except:
            pass

        try:
            names = names.replace("'", '"')
        except:
            pass

        try:
            total_votes = total_votes.replace("'", '"')
        except:
            pass

        try:
            type_description = type_description.replace("'", '"')
        except:
            pass

        try:
            last_analysis_stats = last_analysis_stats.replace("'", '"')
        except:
            pass
        
        try:
            sandbox_verdicts = sandbox_verdicts.replace("'", '"')
        except:
            pass

        try:
            size = size.replace("'", '"')
        except:
            pass


        with open(out + "exe_sample_data.json", "w") as file:
            file.write("[\n")
            file.write(json.dumps(creation_date_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(first_submission_date_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(names_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(total_votes_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(type_description_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(sandbox_verdicts_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(size_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(last_analysis_stats_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(subsystem_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(machine_dict, indent=4))
            file.write("\n,\n")
            file.write(json.dumps(dependWalkerCMD_dict, indent=4))
            file.write("\n]")
    except AttributeError:
            print("Not on Virus Total...")


def getResourceSection(filename):
    exeFileName = ""
    global out
    if rsrc != None:
        command = "ResourceHacker.exe -open " + filename + " -save " + out + "resource.rc -action extract -mask BIN,, -log NULL"
        os.system(command)
        #Extract the data in the .rsrc section and search for an executable signature "MZ"
        #Data is located in the <out>/resource.rc to check the filename of the BIN file
        with open(out+"resource.rc", "r", encoding="utf-16") as file:
            line = file.readline()
            tokens = line.split(" ") #length should be 3
            if len(tokens) != 3:
                return None
            fileType = tokens[1]
            if fileType == "BIN":
                name = tokens[2]
                exeFileName = name[1:(len(name)-2)]
                print(exeFileName)

        #Opens the file within the resource.rc
        with open(out+exeFileName, "rb") as file:
            header = file.read(2)
            if header.decode() == "MZ":
                print("Executable located in the .rsrc section!")
                #add a section to the json file of data 
                #ex: contains rsrc section {False/True}
                #Create directory for rsrc found 
                #Recursively call the methods for the specified rsrc section file
                rsrcFile = out+exeFileName
                out = out + "resourceDirectory/"
                try:
                    if not os.path.exists(out):
                        os.makedirs(out)
                    else:
                        pass
                        #Path already exists
                except FileNotFoundError:
                    pass
                basicStrings(rsrcFile)
                architecture(rsrcFile)
                dependencies(rsrcFile)
                virusTotal(rsrcFile)
                getResourceSection(rsrcFile)
            else:
                print("No executable located in .rsrc section")
    else:
        print("No resource section...")

    

basicStrings(filename)
architecture(filename)
dependencies(filename)
virusTotal(filename)
getResourceSection(filename)